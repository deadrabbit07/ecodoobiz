# Python
---

# 1. 개요

---

**인터프리터**형 프로그래밍 언어이다. 직관적이고 간결하며, 풍부한 표준 라이브러리와 외부 패키지를 갖춘 강력한 생태계를 제공한다. 이로 인해 데이터 분석, 인공지능, 웹 개발, 자동화, 시스템 관리 등 다양한 분야에서 활용되며, 2024 TIOBE 인덱스 기준 **프로그램이 언어 순위 1위**를 기록했다.

<aside>
❓

인터프리터란? 코드를 한 줄씩 읽어 내려가며 실행하는 프로그램을 말한다. 코드 전체를 읽어서 기계여로 번역하는 컴파일러와는 대조적이다.

</aside>

# 2. 철학

---

파이썬의 디자인 철학에 맞는 코드를 짜는 것을 **파이써닉(pythonic)**이라고 부른다. 이는 단순히 스타일 가이드라인을 맞추는 것을 넘어, 파이썬의 파이썬에서 권장되는 다양한 클린 코드 기법을 통해 복잡하지 않고 의미가 명확하며, 명백하게 흐름이 보이는 PEP 20을 염두에 둔 코드를 작성하는 것을 말한다.

<aside>

1. 아름다운 것이 추한 것보다 낫다. (Beautiful is better than ugly.)
2. 명시적인 것이 암시적인 것보다 낫다. (Explicit is better than implicit.)
3. 간결한 것이 복합적인 것보다 낫다. (Simple is better than complex.)
4. 복합적인 것이 복잡한 것보다 낫다. (Complex is better than complicated.)
5. 들여쓰기를 적게 하는 것이 깊은 것보다 낫다. (Flat is better than nested.)
6. 듬성듬성한 것이 밀집한 것보다 낫다. (Sparse is better than dense.)
7. 가독성은 중요하다. (Readability counts.)
8. 특별한 경우는 규칙을 어길 정도로 특별하지 않다. (Special cases aren't special enough to break the rules.)
9. 허나 실용성은 순수성을 이긴다. (Although practicality beats purity.)
10. 오류는 절대로 조용히 지나가지 않아야 한다. (Errors should never pass silently.)
11. 명시적으로 지나가는 것이 아니라면. (Unless explicitly silenced.)
12. 모호함을 마주쳤을 때, 이를 추측하려는 유혹을 거부하라. (In the face of ambiguity, refuse the temptation to guess.)
13. 명확한, 그리고 가급적이면 유일한, 명백한 방법이 있을 것이다. (There should be one-- and preferably only one --obvious way to do it.)
14. 그 방법이 처음에는 명확해 보이지 않을 수 있다.[[3]](https://namu.wiki/w/Python#fn-3). (Although that way may not be obvious at first unless you're Dutch.)
15. 그러나, 지금 행동에 옮기는 것이 아예 안 하는 것보다는 낫다. (Now is better than never.)
16. 아예 안 하는 것이 지금 *당장* 하는 것보다 나을 때도 많다. (Although never is often better than *right* now.)
17. 그러나, 구현 결과를 설명하기 쉽지 않다면, 당장 하는 것은 좋지 않다. (If the implementation is hard to explain, it's a bad idea.)
18. 반대로, 구현 결과를 설명하기 쉽다면, 당장 하는 것은 좋을지도 모른다. (If the implementation is easy to explain, it may be a good idea.)
19. [네임스페이스](https://namu.wiki/w/%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4)를 사용하는 것은 완전 좋은 생각이다 -- 더 많이 이용하자! (Namespaces are one honking great idea -- let's do more of those!)
</aside>

# 3. 특징

---

## 3.1. 쉬운 문법과 높은 가독성

코드 블록을 구분할 때 C나 Java처럼 중괄호`{}` 대신 **들여쓰기**를 사용하는데, 이는 코드의 구조를 명확하게 하여 가독성을 극대화한다. 이는 파이썬의 핵심 철학인 ‘**가독성은 중요하다’**에서 비롯되었다.

## 3.2. 인터프리터 언어

- **빠른 개발 속도**: C나 Java 같은 **컴파일 언어**처럼 전체 컴파일 과정이 필요없어 코드를 작성하는 즉시 테스트하고 결과를 확인할 수 있어 개발과 디버깅 속도가 빠름
- **스크립팅 활용**: 간단한 작업 자동화에 매우 효율적

## 3.3. 객체 지향 및 멀티 패러다임 지원

**객체 지향 프로그래밍(OOP)**을 완벽하게 지원하며, 클래스와 객체를 활용한 개발이 가능하다. 이와 더불어, **절차적 프로그래밍**이나 **함수형 프로그래밍** 등 다양한 프로그래밍 스타일을 모두 지원하는 **멀티 패러다임 언어**다.

## 3.4. 동적 타이핑

C나 Java 같은 **정적 타이핑 언어**와 달리, 변수의 자료형을 코드를 작성할 때 미리 선언할 필요 없이, **코드가 실행되는 시점(런타임)**에 값이 할당 될 때 자료형이 결정된다.

```python
# C/Java (정적 타이핑)에서는 자료형을 명시해야 함
# int x = 10;

# Python (동적 타이핑)에서는 자료형 선언이 필요 없음
x = 10       # x는 정수형(int)이 됨
x = "Hello"  # x는 문자열(str)로 바뀔 수 있음
```

## 3.5. 풍부한 라이브러리와 생태계

이미 다양한 용도로 사용할 수 있는 **표준 라이브러리**를 기본적으로 제공하며, 외부에서도 **수많은** **오픈 소스 라이브러리** **및 프레임워크**가 활발하게 개발되고 있다. 이는 개발자가 모든 것을 처음부터 만들 필요없이 원하는 기능을 쉽게 가져와 사용할 수 있게 해준다.

<aside>
❓

라이브러리란? 개발자가 필요할 때 선택적으로 가져다 쓰는(호출하는) 도구들의 집합이다.

프레임워크란? 프로그램의 전반적인 구조와 틀을 제공하며, 그 안에서 개발자가 코드를 작성하도록 요구하는 뼈대이다.

</aside>

## 3.6. 플랫폼 독립성

Windows, macOS, Linux 등 다양한 운영체제에서 별도의 수정 없이 거의 동일하게 실행된다. 이는 파이썬이 **파이썬 가상 머신(PVM)** 위에서 작동하기 때문이다.

## 3.7. 확장성

‘**Glue Language**’라고도 불리며, C나 C++처럼 성능이 중요한 언어로 작성된 모듈과 쉽게 연결하여 사용할 수 있다. 이로 인해 성능이 필요한 부분은 저수준 언어로 개발하고, 전체 시스템 제어는 파이썬으로 하여 개발 생산성을 높일 수 있다.

# 4. 장단점

---

## 4.1. 장점

- **쉬운 학습 → 직관적인 문법**과 **높은 가독성** 덕분에 초보자도 빠르게 학습 가능
- **빠른 개발속도 → 간결한 문법** 덕분에 **적은 코드**로 동일 기능 구현
- **방대한 라이브러리 → 다양한 기능을 직접 구현**하지 않아도 **바로 활용 가능**
- **풍부한 커뮤니티와 자료 →** 전 세계적으로 사용자가 많아 문제 발생 시 **해결책을 찾기 쉽고, 학습 자료가 풍부**
- **플랫폼 독립적 → 파이썬 가상 머신(PVM)** 덕분에 다양한 운영체제에서 **동일한 코드 실행 가능**
- **대화형 실행 환경 지원 →** 코드를 입력하고 즉시 결과를 확인(REPL)할 수 있어 **실시간 테스트와 디버깅이 편리**

## 4.2. 단점

- **느린 실행 속도 → 인터프리터 방식**이라 C/C++ 같은 **컴파일 언어**보다 속도가 느림
- **멀티 스레딩 제약 → GIL(Global Interpreter Lock)** 때문에 **CPU 집약적인 작업**의 병렬 처리가 제한적
- **런타임 에러 가능성 → 동적 타이핑**으로 타입 오류가 실행 중 발생 가능
- **모바일 앱 개발의 어려움 →** 네이티브 앱 개발이 주력 언어가 아니라 **직접적인 모바일 개발에는 제약**이 따름

<aside>
❓

멀티 스레딩이란? 하나의 프로그램(프로세스) 내에서 여러 작업 흐름(스레드)을 동시에 실행하는 프로그래밍 기법이다.

스레드란? 프로세스(실행 중인 프로그램) 내에서 실제로 작업을 수행하는 가장 작은 실행 단위이다.

GIL이란? 하나의 파이썬 프로세스 내에서 단 하나의 스레드만이 파이썬 바이트코드를 실행할 수 있도록 강제하는 메커니즘이다.

</aside>

# 5. 기본 문법

---

## 5.1. 변수와 데이터 타입

> 타입을 지정하지 않아도 자동으로 인식한다
> 

```python
a = 10        # 정수형 변수
b = 3.14      # 실수형 변수
c = "문자열"   # 문자열 변수
d = True      # 불리언(True/False) 값

x, y, z = 1, 2, 3 # 여러 변수 동시 할당
```

## 5.2. 자료구조

### 5.2.1. 리스트(List) `[]`

파이썬에서 가장 많이 사용되는 자료구조로, 여러 항목을 순서대로 저장할 수 있는 **동적인 배열**이다.

- **특징**:
    - **순서**: 항목이 추가된 순서를 유지 (인데스 사용 가능)
    - **가변성**: 생성된 후에도 항목을 추가, 삭제, 수정 가능
    - **중복 허용**: 동일한 항목을 여러 번 포함 허용
    - **혼합 자료형**: 서로 다른 데이터 타입(정수, 문자열, 다른 리스트 등)을 함께 저장 가능
- **표기**: 대괄호 **`[]`** 를 사용

```python
my_list = ["apple", 10, True]
```

### 5.2.2. 튜플(Tuple) `()`

리스트와 유사하지만, 한번 생성되면 내용을 변경할 수 없는 자료구조이다.

- **특징**:
    - **순서**: 항목의 순서를 유지 (인덱스 사용 가능)
    - **불변성**: 항목을 추가, 삭제, 수정 불가(데이터의 안정성을 보장)
    - **혼합 자료형**: 리스트처럼 다양한 타입 저장 가능
- **용도**: 변경되지 않아야 하는 설정 값이나 함수에서 여러 값을 안전하게 반환할 때 사용
- **표기**: 소괄호 **`()`** 를 사용 (단, 괄호는 필수가 아니며 쉼표가 튜플을 정의한다.)

```python
# 튜플 패킹
my_tuple = ("red", "green", "blue") 

# 튜플 언패킹
x, y = my_tuple                    
 
# 쉼표를 사용하여 튜플 정의 (소괄호 없음)
data = 1, 2, 'hello'.               
```

### 5.2.3. 딕셔너리(Dictionary) `{ Key : Value }`

항목을 **키(Key)**와 **값(Value)** 쌍으로 저장하는 자료구조이다. 순서가 아닌 **키**를 통해 값에 접근한다.

- **특징**:
    - **키-값 쌍**: 각 항목은 고유한 키와 해당 키에 연결된 값으로 구성
    - **순서 유지 (Python 3.7+)**: 최근 버전에서는 항목이 추가된 순서를 유지
    - **가변성**: 생성된 후에도 키-값 쌍을 추가, 삭제, 수정 가능
    - **키의 불변성**: 키는 문자열, 숫자, 튜플 등 **불변 자료형**만 사용 가능
- **용도**: 데이터베이스의 레코드처럼 이름(키)을 통해 빠르게 데이터를 찾고자 할 때 유용
- **표기**: 중괄호 **`{}`** 를 사용하며, 키와 값은 **콜론`:`**으로 구분

```python
my_dict = {"name": "Alice", "age": 30}
```

### 5.2.4. 집합(Set) `{}`

**중복을 허용하지 않고 순서가 없는** 항목들의 모음이다.

- **특징**:
    - **순서 없음**: 항목에 인덱스가 없어 순서에 기반한 접근이 불가
    - **중복 불허**: 모든 항목은 고유 필수 (중복된 값을 자동으로 제거)
    - **가변성**: 항목을 추가하거나 삭제 가능
- **용도**: 항목의 중복을 빠르게 제거하거나, 두 집합 간의 합집합, 교집합, 차집합 등의 **수학적 집합 연산**을 수행할 때 사용
- 표기: 중괄호 **`{}`** 를 사용 (빈 집합은 `set()` 으로 생성해야 한다. `{}` 는 빈 딕셔너리이다.)

```python
my_set = {"A", "B", "C", "A"} 
# 결과는 {'A', 'B', 'C'}
```

## 5.3. 출력

값을 출력하는 주된 방식은 `print()` 함수를 사용하는 것이며, 그 내부에서 데이터를 **서식(Formatting)** 하는 방식이 여러 가지 있다.

### 5.3.1. 기본 출력 및 쉼표 구분

흔히 쓰는 방식으로, `print()` 함수 안에 여러 값을 쉼표`,` 로 구분하여 나열하면, 해당 값들이 **공백**을 사이에 두고 연속해서 출력된다.

- **특징**: 출력되는 값의 타입에 관계없이 자동으로 문자열로 변환

```python
name = "앨리스"
age = 25

# 쉼표로 값 나열 시, 자동으로 공백이 추가됨
print("이름:", name, "나이:", age)
# 출력: 이름: 앨리스 나이: 25
```

### 5.3.2. `.format()` 메서드

문자열의 특정 위치에 **중괄호`{}`** 로 표시된 **플레이스홀더(Placeholder)**를 만들어 두고, `.format()` 메서드를 사용하여 값을 채워 넣는 방식이다.

- 특징:
    - 플레이스홀더 순서대로 값을 채우거나 (순서 지정 안 함)
    - 플레이스홀더 내에 인덱스 번호나 이름을 지정하여 값을 입력 가능

```python
# 1. 순서 기반 (중괄호만 사용)
print("저는 {}살이며, 사는 곳은 {}입니다.".format(30, "서울"))
# 출력: 저는 30살이며, 사는 곳은 서울입니다.

# 2. 이름 기반 (가독성이 좋음)
print("제품: {product}, 가격: {price}원".format(price=50000, product="키보드"))
# 출력: 제품: 키보드, 가격: 50000원
```

### 5.3.3. f-문자열 (f-string) - 권장 방식

3.6 버전 이후에 도입된 방식으로, 문자열 앞에 **`f`**를 붙이고 중괄호`{}` 안에 **변수나 표현식을 직접** 넣어 출력한다. 현재 파이썬에서 가장 권장되는 출력 방식이다.

- **특징**: 가장 간결하고 가독성이 높으며, 문자열 내에서 변수 값을 즉시 확인하고 표현식 계산도 가능

```python
product = "마우스"
price = 35000

# f를 붙이고 중괄호 안에 변수를 직접 넣음
print(f"제품명: {product}, 할인 가격: {price * 0.9}원")
# 출력: 제품명: 마우스, 할인 가격: 31500.0원
```

## 5.4. 조건문

프로그램의 **흐름을 제어**하는 기본적인 문법 요소로, 주어진 **조건**이 참(True)인지 거짓(False)인지에 따라 실행할 코드 블록을 결정한다.

### 5.4.1. `if` (만약 ~라면)

가장 기본적인 조건문으로, **조건이 참일 때**만 코드 블록을 실행한다.

- **문법**: `if` 키워드 뒤에 조건식을 쓰고 콜론`:` 으로 마무리, 실행할 코드는 반드시 **들여쓰기**

```python
score = 95

if score >= 90: # 조건: score가 90 이상이다 (참)
    print("A 학점입니다.")
```

### 5.4.2. `elif` (그렇지 않고 만약 ~라면)

첫 번째 `if` 조건이 거짓일 때, **다음 조건을 검사한**다. 여러 개의 조건을 순차적으로 확인할 때 사용한다.

- **문법:** `elif` 키워드를 사용하며, `if` 블록 바로 뒤에 위치

```python
score = 85

if score >= 90:
	print("A 학점입니다.")
elif socore >= 80: # 첫 번째 조건이 거짓이므로 이 조건 검사 (참)
	print("B 학점입니다.")
```

### 5.4.3. `else` (그렇지 않다면)

위에 나열된 **모든 조건(`if`, `elif`)이 거짓일 때** 실행되는 코드 블록이다. `else`는 조건을 지정하지 않으며, 선택 사항이다.

- **문법:** `else` 키워드만 사용하고 콜론(:)으로 마무리합니다.

```python
score = 73

if socore >= 90:
	print("A 학점입니다.")
elif score >= 80:
	print("B 학점입니다.")
else: # 위의 모든 조건이 거짓이므로 이 블록이 실행됨
	print("C 학점 이하")
```

## 5.5.  반복문

특정 코드 블록을 반복적으로 실행하여 작업을 자동화하거나 데이터의 집합을 순회할 때 사용된다. 주로 두 가지 형태의 반보문인 `for` 문과 `while` 문을 제공한다.

### 5.5.1. `for` 반복문: 순회 기반 반복

`for` 문은 리스트, 튜플, 문자열 등 **순회 가능한(Iterable) 객체**의 각 요소를 **하나씩** 꺼내어 코드를 반복 실행할 때 사용된다.

- **용도:** 항목의 개수가 정해져 있거나, 데이터 컬렉션 전체를 다룰 때 적합
- **구조:** `for [변수] in [순회 가능한 객체]:`

```python
# 리스트 순회 예시
fruits = ["apple", "banana", "cherry"]

for fruit in fruits:  # 리스트의 요소를 'fruit' 변수에 순서대로 할당하며 반복
    print(f"I like {fruit}.")
# 출력: I like apple.
# 출력: I like banana.
# 출력: I like cherry.

# 숫자 범위 반복 (range() 함수 사용)
for i in range(3): # 0, 1, 2 순서대로 반복
    print(i)
# 출력: 0, 1, 2
```

### 5.5.2. `while` 반복문: 조건 기반 반복

`while` 문은 주어진 **조건식**이 **참(True)**인 동안 코드 블록을 계속해서 반복 실행한다.

- **용도:** 반복 횟수가 명확하지 않고, 특정 조건이 만족될 때까지 반복해야 할 때 적합
- **구조:** `while [조건식]:`
- **주의:** 조건이 영원히 참이 되는 **무한 루프**를 방지하기 위해, 반복문 내부에 조건을 거짓으로 바꿀 수 있는 코드를 반드시 포함

```python
# while 문 예시
count = 0

while count < 3:  # 조건: count가 3보다 작다 (참인 동안 반복)
    print(f"현재 횟수: {count}")
    count += 1    # 반복을 끝내기 위해 count를 증가시킴

# 출력: 현재 횟수: 0
# 출력: 현재 횟수: 1
# 출력: 현재 횟수: 2
```

## 5.6. 함수

### 5.6.1. 함수 정의 및 호출

`def` 키워드를 사용하여 정의하며, 함수 이름 뒤에 소괄호`()` 와 콜론`:` 을 붙여 시작한다. 함수 본문(실행할 코드)은 반드시 **들여쓰기** 해야 한다.
함수를 정의하는 것만으로는 코드가 실행되지 않으며, 함수 이름과 소괄호`()`를 사용하여 함수를 **호출**해야 코드가 실행된다.

- **구조:** `def [함수_이름]([매개변수]):`

```python
# 'greet'이라는 이름의 함수 정의
def greet(name): # 'name'은 매개변수
    print(f"안녕하세요, {name}님!")

greet("앨리스") # 함수 호출, "앨리스"는 전달인자
# 출력: 안녕하세요, 앨리스님!
```

<aside>
❓

매개변수란? 함수를 정의할 때 소괄호 안에 명시하는 입력 변수

전달인자란? 함수를 호출할 때 매개변수에 실제로 전달하는 값

</aside>

### 5.6.2. 반환 값 (Return Value)

함수가 작업을 수행한 후, 그 **결과 값을 호출한 곳으로 되돌려 줄 때** `return` 키워드를 사용한다.

- **`return` 사용**: `return`은 함수를 **종료**하고 지정된 값을 반환
    
    ```python
    def add(a, b):
        result = a + b
        return result # 계산 결과인 result 값을 반환
    
    sum_result = add(5, 3) # 함수 호출 후 반환 값을 변수에 저장
    print(sum_result) # 출력: 8
    ```
    
- **`return` 생략 또는 명시적 반환 값 없음**: 함수가 `return` 문을 사용하지 않거나, `return`만 단독으로 사용할 경우, 자동으로 특별한 값인 `None`을 반환
    
    ```python
    def print_only(data):
        print(data) # 반환 문이 없음
    
    return_value = print_only("Hello")
    print(return_value) # 출력: None
    ```
    
    | 사용 시점 | 목적 (함수의 역할) | 결과 |
    | --- | --- | --- |
    | **`return`이 꼭 있어야 할 때** | 함수가 **데이터를 계산, 생성, 처리**해서 
    그 **결과를 다른 코드(호출자)에게 전달**해야 할 때 | 호출한 곳으로 **명시적인 값**이 
    반환 |
    | `return`이 없어도 될 때 | 함수가 **특정 동작(Action)**만 수행하고, 
    **별도의 결과 데이터를 돌려줄 필요가 없을 때** 
    (예: 출력, 파일 저장, 상태 변경). | 파이썬이 자동으로 `None`을 
    반환 |

## 5.7. 모듈 가져오기

모듈(Module)은 기본적으로 파이썬 코드가 담긴 하나의 `.py` 파일이다. 이 파일 안에는 함수, 클래스, 변수 등이 정의되어 있다.

- **가져오기의 목적**: 다른 개발자가 이미 만들어 놓은 유용한 기능을 현재 코드에서 복사해서 붙여넣을 필요 없이 바로 사용할 수 있게 한다.

### 5.7.1. 모듈 전체 가져오기 (`import)`)

가장 기본적인 방식으로, 모듈의 모든 내용을 가져온다. 코드가 길어지더라도, **어떤 모듈에서 온 기능인지 명확**하게 알 수 있어 충돌을 방지하는 데 좋다.

```python
import random
result = random.randint(1, 100) # 'random.'을 명시해야 함
```

### 5.7.2. 별칭(Alias)을 사용하여 가져오기 (`import ... as ...`)

모듈 이름이 너무 길거나, 자주 사용해야 할 때 **짧은 별명**을 붙여서 사용한다. 이는 특히 **데이터 과학 분야(Pandas, NumPy)**에서 관례처럼 사용된다.

```python
import pandas as pd # pandas 모듈에 'pd'라는 별칭을 부여

data = pd.DataFrame() # 짧은 별칭으로 사용
```

### 5.7.3. 특정 요소만 가져오기 (`from ... import ...`)

모듈 전체가 아니라, 그 안에 정의된 **특정 함수나 변수만** 골라서 가져올 수 있다.

**⚠️ 주의:** 특정 요소만 가져올 경우, 다른 모듈이나 코드에서 같은 이름의 함수를 정의했을 때 **이름 충돌**이 발생할 수 있으므로 주의해야 한다.

```python
from time import sleep # time 모듈에서 'sleep' 함수만 가져옴

print("잠시 후 실행...")
sleep(2) # 모듈 이름 없이 함수 이름만으로 바로 사용 가능 (코드가 간결해짐)
print("2초 경과")
```

## 5.8. 컴프리헨션

**반복 가능한 객체(interable)**를 기반으로 **새로운 컬렉션을 간결하게 생성**하는 문법적 구조를 통칭한다. 리스트, 튜플, 딕셔너리, 집합에 대한 컴프리헨션이 있다.
컴프리헨션은 코드를 **한 줄로 압축**하여 가독성을 높이고, 전통적인 `for` 루프보다 성능상 효율적이기 때문에 파이썬의 ‘**Pythonic**’ 코드 작성법으로 간주된다.

### 5.8.1. 리스트 컴프리헨션 (List Comprehension)

가장 흔하며, 대괄호`[]` 를 사용하여 새로운 리스트를 생성한다.

- **구조:** `[ 표현식 for 항목 in 순회가능객체 if 조건 ]`
- **용도:** 기존 리스트를 변형하거나 필터링하여 새로운 리스트를 만들 때

```python
# 모든 항목을 제곱한 새 리스트 생성
squares = [x * x for x in range(5)]
print(squares) # 결과: [0, 1, 4, 9, 16]
```

### 5.8.2. 딕셔너리 컴프리헨션 (Dictionary Comprehension)

중괄호`{}` 를 사용하며, 항목을 **`키: 값`** 쌍의 형태로 생성하여 새로운 딕셔너리를 만든다.

- **구조:** `{ 키_표현식: 값_표현식 for 항목 in 순회가능객체 if 조건 }`
- **용도:** 두 개의 리스트를 합쳐 딕셔너리를 만들거나, 기존 딕셔너리의 키나 값을 변형할 때

```python
# 리스트를 기반으로 {숫자: 제곱} 형태의 딕셔너리 생성
squares_dict = {x: x * x for x in range(3)}
print(squares_dict) # 결과: {0: 0, 1: 1, 2: 4}
```

### 5.8.3. 집합 컴프리헨션 (Set Comprehension)

중괄호`{}` 를 사용하지만, **`키: 값` 쌍 없이** 단일 항목만 포함하여 새로운 집합을 생성한다. 집합의 특성상 **중복된 값은 자동으로 제거된**다.

- **구조:** `{ 표현식 for 항목 in 순회가능객체 if 조건 }`
- **용도:** 데이터 컬렉션에서 중복을 제거하면서 항목을 변형할 때

```python
# 중복이 포함된 리스트를 받아 중복을 제거하고 대문자로 변환
chars = ['a', 'b', 'a', 'c']
unique_upper = {c.upper() for c in chars}
print(unique_upper) # 결과: {'A', 'B', 'C'} (순서 보장 안 됨)
```

### 5.8.4. 제너레이터 표현식 (Generator Expression)

문법적으로는 **튜플과 같은 소괄호 `()`**를 사용하지만, 이는 **튜플 컴프리헨션이 아니다.** 튜플을 즉시 생성하는 대신, 필요한 순간에 값을 **하나씩 생성하는 제너레이터** 객체를 만듭니다.

- **구조:** `( 표현식 for 항목 in 순회가능객체 if 조건 )`
- **용도:** 메모리 효율이 중요할 때. 전체 데이터를 한꺼번에 메모리에 올리지 않고, 필요할 때마다 값을 생성하여 메모리 사용량을 최소화합니다

```python
# 제너레이터 객체 생성 (아직 값이 생성되지 않음)
gen_expr = (x * 2 for x in range(5))

# 값을 요청할 때마다 생성됨
print(next(gen_expr)) # 결과: 0
print(next(gen_expr)) # 결과: 2
```

<aside>
❓

제네레이터란? 순회 가능한 객체를 생성하는 특별한 종류의 함수이다. 일반 함수가 값을 한 번 계산하고 `return` 으로 돌려준 후 종료되는 것과 달리, 제너레이터는 **필요할 때마다 값을 하나씩 생성하며** 실행을 **일시 중지하고 재개**할 수 있다.

</aside>

| 구분 | 컴프리헨션 사용 **권장** (장점) | 컴프리헨션 사용 **지양** (단점) |
| --- | --- | --- |
| **간결성/생산성** | 짧고 단순한 로직으로 새로운 리스트/딕셔너리 등을 생성할 때 | 로직이 너무 복잡하여 **한 줄에 담기 어려울 때** (예: 중첩된 `for` 루프가 2개 이상일 때) |
| **가독성** | 코드가 한 줄로 깔끔하게 정리되어 로직 파악이 쉬울 때 | 표현식과 조건이 길어지거나 복잡해져서 **한눈에 이해하기 어려울 때** |
| **성능** | 새로운 컬렉션을 생성할 때, 일반 `for` 루프보다 **약간 더 빠르기** 때문에 성능이 중요할 때 | 컴프리헨션이 너무 길거나 복잡하면 디버깅이 어려워져 **유지보수 비용**이 높아질 때 |
| **목적** | **반드시 새로운 컬렉션을 생성**하는 것이 목적일 때 | 단순히 항목을 출력하거나(Side Effect), **특정 행위**를 수행하는 것이 목적인 경우 |

## 5.9. 주석

프로그래밍 코드 내에 삽입하는 **설명 텍스트**로, 프로그램의 동작에는 영향을 주지 않는다. 주석의 주된 목적은 **코드의 가독성을 높이고** 개발자가 코드를 이해하고 유지보수하는 데 도움을 주는 것이다.

### 5.9.1 한 줄 주석 (Inline Comment)

한 줄 주석은 **`#`** 기호로 시작하며, 해당 기호 뒤에 나오는 모든 내용은 인터프리터에 의해 무시된다.

```python
# 이 줄은 주석이다. 인터프리터는 이 부분을 무시한다.
x = 10 # 변수에 값을 할당하는 코드 옆에도 주석을 달 수 있다.
```

### 5.9.2 여러 줄 주석 (Docstring)

공식적인 '여러 줄 주석' 구문이 따로 없지만, 보통 **세 개의 따옴표(`"""` 또는 `'''`)**로 감싸는 문자열을 사용하여 여러 줄 주석처럼 활용한다.

이 문자열을 특히 **함수, 클래스, 모듈 바로 아래**에 작성하면, 이는 단순 주석이 아니라 코드의 공식적인 **문서(Documentation)** 역할을 하는 **독스트링(Docstring)**이 된다.

```python
def calculate_sum(a, b):
    """
    이것이 독스트링입니다.
    여러 줄에 걸쳐 함수에 대한 자세한 설명을 작성합니다.
    (예: 이 함수는 두 숫자의 합을 반환합니다.)
    """
    return a + b
```

# 6. 코딩 컨벤션

---

개발자들이 코드를 작성할 때 일관성을 유지하고 가독성을 높이기 위해 지켜야 하는 **일반적인 규칙과 스타일 약속**을 총칭하는 용어이다.

이러한 규칙은 단순히 '프로그램이 돌아가게 하는 것'을 넘어, **'사람이 읽고 이해하기 쉽게'** 만드는 데 목적이 있습니다.

- **목적:** 가독성 향상, 협업 효율 증대, 유지보수 용이성 확보
- **포함 요소:** 변수 및 함수 이름 짓기, 들여쓰기 방식, 공백 사용, 코드 줄 길이 제한 등

## 6.1. PEP 8 (Python Enhancement Proposal 8)

파이썬 코드를 **일관성 있게** 작성하기 위해 파이썬 커뮤니티에서 합의한 **공식적인 코딩 컨벤션(Coding Convention)**이자 **스타일 가이드라인**이다.

### 6.1.1 주요 핵심 규칙

PEP 8은 매우 광범위하지만, 개발자가 가장 자주 접하고 지켜야 하는 핵심 규칙들은 다음과 같다.

| 구분 | 규칙 | 세부 내용 및 예시 |
| --- | --- | --- |
| **들여쓰기
(Indentation)** | **공백 4칸** 사용을 강제 | 탭(Tab)을 사용하지 않고, 4개의 공백(Space)으로 들여쓰기 합니다. |
| **줄 길이
(Line Length)** | 한 줄의 최대 길이는 **79자**로 제한 | 코드를 너무 길게 작성하지 않아 가독성을 유지합니다.
(Docstring 및 주석은 72자 권장) |
| **명명 규칙
(Naming)** | 요소별로 정해진 스타일을 따름 | • **변수/함수:** `snake_case` (예: `user_name`) 
• **클래스:** `PascalCase` (예: `UserAccount`) 
• **상수:** 모두 대문자 (예: `MAX_SIZE`) |
| **공백
(Whitespace)** | 연산자 주변에 공백을 사용하여 가독성 확보 | • 이항 연산자(=, +, and 등) 양쪽에 공백 사용: `a = b + 1` (**O**) |
| **빈 줄
(Blank Lines)** | 논리적인 그룹 구분을 위해 빈 줄 사용 | • 최상위 함수 및 클래스 정의 사이: **두 줄** 
• 클래스 내부의 메서드 정의 사이: **한 줄** |
| **`import`** | 파일의 최상단에 모아서 작성 | • 모듈 전체를 가져오는 `import`와 특정 요소만 가져오는 `from` import를 구분합니다. |
| 비교 연산자
(Comparison) | 복잡한 비교는 축약하지 않고 명시적으로 작성 | •`if x is None:` (O) / `if x == None:` (X) |
| 주석
(Comments) | 문법과 내용에 일관된 스타일 유지 | • 한 줄 주석 `#` 뒤에는 공백 하나 사용: `#` This is a comment 
• Docstring은 "를 사용하여 함수, 클래스 설명에 활용 |